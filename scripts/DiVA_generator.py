#!/usr/bin/python3
# -*- coding: utf-8 -*-
# -*- mode: python; python-indent-offset: 4 -*-

import json
import os
import re
import bibtexparser

MAP_FILE = 'publications_map.json'
OUTPUT_FILE = 'lib/publications_generated.tex'

ENV_MAP = {
    'paper': 'ListOfPapers',
    'patent': 'ListOfPatents',
    'artifact': 'ListOfArtifacts',
    'poster': 'ListOfPosters',
    'patentapplication': 'ListOfPatentApplications',
    'report': 'ListOfReports',
    'dataset': 'ListOfDatasets'
}

def get_valid_bib_keys(bib_file):
    """Returns a set of all entry IDs present in the .bib file."""
    if not os.path.exists(bib_file):
        print(f"Warning: {bib_file} not found.")
        return set()
    try:
        with open(bib_file, 'r', encoding='utf-8') as f:
            bib_database = bibtexparser.load(f)
            return {entry['ID'] for entry in bib_database.entries}
    except Exception as e:
        print(f"Error parsing .bib file: {e}")
        return set()

def clean_latex_string(text):
    """Cleans a string for LaTeX while preserving math mode."""
    if not text: return ""
    text = re.sub(r'\s+', ' ', text).strip()
    parts = re.split(r'(\$.*?\$)', text)
    mapping = {
        '&': r'\&', '%': r'\%', '$': r'\$', '#': r'\#',
        '_': r'\_', '{': r'\{', '}': r'\}',
        '~': r'\textasciitilde{}', '^': r'\textasciicircum{}'
    }
    cleaned_parts = []
    for part in parts:
        if part.startswith('$') and part.endswith('$'):
            cleaned_parts.append(part)
        else:
            local_mapping = mapping.copy()
            del local_mapping['$'] 
            temp_part = part
            for char, escape in local_mapping.items():
                temp_part = temp_part.replace(char, escape)
            cleaned_parts.append(temp_part)
    return "".join(cleaned_parts)

def clean_bib_key(key):
    """Escapes underscores in BibTeX keys for display in LaTeX text."""
    if not key: return ""
    return key.replace('_', r'\_')

def generate_latex():
    valid_keys = get_valid_bib_keys('references.bib')
    if not os.path.exists(MAP_FILE):
        print(f"Error: {MAP_FILE} not found.")
        return

    with open(MAP_FILE, 'r', encoding='utf-8') as f:
        pub_map = json.load(f)

    grouped_entries = {env: [] for env in ENV_MAP.values()}
    included_diva_ids = [] # For the Cleanup reference list
    
    for diva_id, data in pub_map.items():
        if data.get('status') == 'included' and data.get('label'):
            try:
                prefix, identifier = data['label'].split(':')
                env_name = ENV_MAP.get(prefix)
                if env_name:
                    included_diva_ids.append(diva_id)
                    target_key = data.get('better_bib_key') or data.get('bib_key')
                    is_key_valid = target_key in valid_keys if target_key else False
                    raw_title = data.get('full title') or data.get('title', 'Untitled')
                    display_title = clean_latex_string(raw_title)

                    grouped_entries[env_name].append({
                        'id': identifier,
                        'title': display_title,
                        'bib_key': target_key,
                        'is_valid': is_key_valid,
                        'prefix': prefix
                    })
            except ValueError:
                print(f"Warning: Invalid label format for {diva_id}: {data['label']}")

    latex_output = ["% --- Generated by DiVA_generator.py ---", ""]

    for env_name in ENV_MAP.values():
        entries = grouped_entries[env_name]
        if not entries: continue
        
        entries.sort(key=lambda x: x['id'])
        latex_output.append(f"\\begin{{{env_name}}}")
        for entry in entries:
            label_cmd = f"\\label{{{entry['prefix']}:{entry['id']}}}"
            
            if entry['is_valid']:
                cite_str = f"\\cite{{{entry['bib_key']}}}"
            else:
                # descriptive error message for missing keys
                key_display = clean_bib_key(entry['bib_key']) if entry['bib_key'] else "None"
                cite_str = f"\\textbf{{[Missing BibTeX entry: {key_display}]}}"
            
            latex_output.append(f"  \\item {label_cmd} {entry['title']} {cite_str}")
            
        latex_output.append(f"\\end{{{env_name}}}")
        latex_output.append("")

    # --- Cleanup / Reference Section (Commented out in LaTeX) ---
    latex_output.append("% --- Included DiVA IDs for Reference ---")
    for d_id in sorted(included_diva_ids):
        latex_output.append(f"% {d_id}")

    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("\n".join(latex_output))
    
    print(f"Successfully generated {OUTPUT_FILE} with {len(included_diva_ids)} publications.")

if __name__ == "__main__":
    generate_latex()
